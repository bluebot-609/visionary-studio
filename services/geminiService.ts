import { GoogleGenAI, Type, Modality } from "@google/genai";
import type { UploadedFile, Concept, CreativeBrief } from '../types';
import { CREATIVE_BRIEF_OPTIONS } from '../options';

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

export const fileToGenerativePart = (file: UploadedFile) => {
  return {
    inlineData: {
      data: file.base64,
      mimeType: file.type
    },
  };
};

// Refactored to accept master prompt directly (generated by agents)
export const generateImages = async (
  masterPrompt: string,
  aspectRatio: string,
  imageFile?: UploadedFile
): Promise<{ images: string[], prompt: string }> => {
  // Handle image-to-image generation (with a reference file)
  if (imageFile) {
    // Calculate aspect ratio dimensions for clarity
    const aspectRatioMap: Record<string, string> = {
      '1:1': 'square (1:1)',
      '3:4': 'portrait (3:4)',
      '4:3': 'landscape (4:3)',
      '9:16': 'vertical/portrait (9:16)',
      '16:9': 'horizontal/landscape (16:9)',
      '4:5': 'portrait (4:5)'
    };
    const aspectRatioDescription = aspectRatioMap[aspectRatio] || aspectRatio;

    const imageToImagePrompt = `CRITICAL INSTRUCTIONS FOR IMAGE GENERATION:

**ðŸŽ¯ PRIMARY RULE - PRODUCT INTEGRITY MUST BE PRESERVED:**

The reference image contains a PRODUCT that is the core subject of this ad creative. Your task is to:
1. **PRESERVE the product's appearance EXACTLY as shown in the reference image** - do NOT alter, re-imagine, or modify the product itself
2. Place this product in a new, professionally composed scene according to the specifications below
3. The product's colors, textures, design, branding, and visual identity MUST remain identical to the reference

**WHAT TO PRESERVE (DO NOT CHANGE):**
- âœ… Product shape, form, and design
- âœ… Product colors and color scheme
- âœ… Product textures and materials
- âœ… Brand logos, text, and labels on the product
- âœ… Product packaging design
- âœ… Product proportions and scale
- âœ… Product's visual identity

**WHAT TO CHANGE (Create New):**
- âŒ Background and environment
- âŒ Lighting setup and atmosphere
- âŒ Scene composition and staging
- âŒ Models or props (if specified)
- âŒ Overall mood and aesthetic
- âŒ Camera angle and perspective

**MANDATORY ASPECT RATIO REQUIREMENT:**
- The output image MUST have an aspect ratio of EXACTLY ${aspectRatio} (${aspectRatioDescription})
- If aspect ratio changes, extend or adjust the SCENE and BACKGROUND, but keep the product itself intact
- The output image dimensions must match ${aspectRatio} exactly

**HOW TO HANDLE ASPECT RATIO CHANGES:**
- If the new aspect ratio is wider: Extend the scene/background horizontally (add more environment, not more product)
- If the new aspect ratio is taller: Extend the scene/background vertically (add more environment, not more product)
- If the new aspect ratio is narrower: Adjust composition while keeping product centered and visible
- CRITICAL: The product itself should maintain its original proportions and appearance regardless of aspect ratio changes

**PRODUCT PLACEMENT REQUIREMENTS:**
- Position the product according to the composition guidelines below
- Ensure the product remains the primary or co-primary focal point
- If models are specified, ensure product is visible and not obscured
- Maintain product clarity and recognizability

=== DETAILED SHOT PLAN ===
${masterPrompt}

**FINAL CHECKLIST:**
âœ… Product appearance is preserved exactly from reference image
âœ… Product colors, textures, and design match the reference
âœ… Brand elements (logos, text) are intact and legible
âœ… Scene, lighting, and composition follow the shot plan specifications
âœ… Output aspect ratio is exactly ${aspectRatio} (${aspectRatioDescription})
âœ… Product is clearly visible and prominent in the final image`;

    const imagePart = fileToGenerativePart(imageFile);
    const textPart = { text: imageToImagePrompt };
    
    // Ensure aspect ratio is in the correct format for the API
    const apiAspectRatio = aspectRatio as "1:1" | "3:4" | "4:3" | "9:16" | "16:9";
    
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: { parts: [imagePart, textPart] },
      config: { 
        responseModalities: [Modality.IMAGE],
        imageConfig: {
          aspectRatio: apiAspectRatio,
        },
      },
    });

    const imagePartResponse = response.candidates?.[0]?.content?.parts?.find(part => part.inlineData);
    const images = imagePartResponse?.inlineData?.data ? [imagePartResponse.inlineData.data] : [];
    return { images, prompt: imageToImagePrompt };
  } 
  
  // Handle text-to-image generation (no reference file)
  else {
    const response = await ai.models.generateImages({
      model: 'imagen-4.0-generate-001',
      prompt: masterPrompt,
      config: {
        numberOfImages: 1,
        aspectRatio: aspectRatio as "1:1" | "3:4" | "4:3" | "9:16" | "16:9",
      },
    });
    
    const images = response.generatedImages.map(img => img.image.imageBytes);
    return { images, prompt: masterPrompt };
  }
};

export const generateCaptions = async (imageBase64: string) => {
    const imagePart = {
        inlineData: { data: imageBase64, mimeType: 'image/jpeg' }
    };
    const textPart = { text: "Analyze this image and generate 3 creative, trending captions: one in English, one in Hindi (using Devanagarai script), and one in Hinglish (Hindi written in Latin script). Also provide a 'slightly seductive' version for each of the three captions."};
    
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: { parts: [imagePart, textPart] },
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.OBJECT,
                properties: {
                    english: { type: Type.STRING },
                    hindi: { type: Type.STRING },
                    hinglish: { type: Type.STRING },
                    seductiveEnglish: { type: Type.STRING },
                    seductiveHindi: { type: Type.STRING },
                    seductiveHinglish: { type: Type.STRING },
                }
            }
        }
    });

    try {
        const jsonText = response.text.trim();
        return JSON.parse(jsonText);
    } catch (e) {
        console.error("Failed to parse captions JSON:", e);
        return null;
    }
};

export const getCreativeBriefSuggestions = async (creativeGoal: string, imageFile?: UploadedFile): Promise<Partial<CreativeBrief> | null> => {
  const prompt = `As a world-class creative director, analyze the following creative goal, and the provided reference image if any. Based on this, suggest the optimal settings for a photoshoot.
  Your response MUST be a JSON object. For each key, you MUST select the single most appropriate value from the provided list of options.

  Creative Goal / Description: "${creativeGoal || 'Not provided'}"

  Here are the available options for each category:
  - aspectRatio: [${CREATIVE_BRIEF_OPTIONS.aspectRatio.map(o => `'${o}'`).join(', ')}]
  - cameraAngle: [${CREATIVE_BRIEF_OPTIONS.cameraAngle.map(o => `'${o}'`).join(', ')}]
  - modelType: [${CREATIVE_BRIEF_OPTIONS.modelType.map(o => `'${o}'`).join(', ')}]
  - environment: [${CREATIVE_BRIEF_OPTIONS.environment.map(o => `'${o}'`).join(', ')}]
  - presentation: [${CREATIVE_BRIEF_OPTIONS.presentation.map(o => `'${o}'`).join(', ')}]
  - mood: [${CREATIVE_BRIEF_OPTIONS.mood.map(o => `'${o}'`).join(', ')}]
  - colorGrading: [${CREATIVE_BRIEF_OPTIONS.colorGrading.map(o => `'${o}'`).join(', ')}]
  - lighting: [${CREATIVE_BRIEF_OPTIONS.lighting.map(o => `'${o}'`).join(', ')}]
  - realismLevel: [${CREATIVE_BRIEF_OPTIONS.realismLevel.map(o => `'${o}'`).join(', ')}]
  - skinTexture: [${CREATIVE_BRIEF_OPTIONS.skinTexture.map(o => `'${o}'`).join(', ')}]
  - hairDetail: [${CREATIVE_BRIEF_OPTIONS.hairDetail.map(o => `'${o}'`).join(', ')}]
  - manipulationStyle: [${CREATIVE_BRIEF_OPTIONS.manipulationStyle.map(o => `'${o}'`).join(', ')}]

  Select only one option for each key.
  `;

  const contents = imageFile ? { parts: [fileToGenerativePart(imageFile), { text: prompt }] } : prompt;
  
  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash',
    contents: contents,
    config: {
      responseMimeType: "application/json",
      responseSchema: {
        type: Type.OBJECT,
        properties: {
          aspectRatio: { type: Type.STRING },
          cameraAngle: { type: Type.STRING },
          modelType: { type: Type.STRING },
          environment: { type: Type.STRING },
          presentation: { type: Type.STRING },
          mood: { type: Type.STRING },
          colorGrading: { type: Type.STRING },
          lighting: { type: Type.STRING },
          realismLevel: { type: Type.STRING },
          skinTexture: { type: Type.STRING },
          hairDetail: { type: Type.STRING },
          manipulationStyle: { type: Type.STRING },
        }
      }
    }
  });

  try {
    const jsonText = response.text.trim();
    return JSON.parse(jsonText);
  } catch (e) {
    console.error("Failed to parse suggestions JSON:", e);
    return null;
  }
};

export const analyzeWebsiteForConcepts = async (url: string): Promise<Concept[]> => {
    const prompt = `Analyze the brand identity, aesthetic, and target audience of the website at this URL: ${url}.
Based on your analysis, generate 3-5 distinct and creative marketing or design concepts that would align with this brand.
For each concept, provide a concise title and a short description.
Your response must be a valid JSON array of objects, where each object has a "title" and "description" key.
Example format:
[
  {
    "title": "Concept Title 1",
    "description": "A short description of the concept."
  },
  {
    "title": "Concept Title 2",
    "description": "Another short description."
  }
]

IMPORTANT: Only output the raw JSON array. Do not include any other text, markdown formatting (like \`\`\`json), or explanations.`;

    const response = await ai.models.generateContent({
        model: 'gemini-2.5-pro',
        contents: prompt,
        config: {
            tools: [{ googleSearch: {} }]
        }
    });

    try {
        const rawJson = response.text.trim().replace(/^```json\n?/, '').replace(/\n?```$/, '');
        const concepts = JSON.parse(rawJson);
        return concepts;
    } catch (e) {
        console.error("Failed to parse website analysis JSON:", e);
        console.error("Gemini response text:", response.text);
        return [];
    }
};